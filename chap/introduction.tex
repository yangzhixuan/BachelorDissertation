
% \specialchap{序言}
\chapter{序言}

指针是一类用于对程序中变量进行指代、引用的编程语言构造，其在不同范式的众多编程语言中都广泛地存在。在C语言中，指针是语言的“一等公民”，程序员可以自由创建指针、使指针指向不同的变量、并通过指针访问其所指向的变量。在Python, Javascript等语言中，指针\footnote{在此类语言中，往往称之为“引用”而不是“指针”。本文则一律称作“指针”。}则被隐式地广泛使用，程序员创建的每个变量概念上都是指向某个对象的指针，且程序员只能通过这些隐式的指针访问变量。在一些函数式编程语言，如ML语言中，也提供指针的构造\footnote{即引用类型\texttt{ref T}。}，不过语言中“纯”（函数式）的变量与“不纯”的变量被区分开，指针只能指向不纯的变量。甚至在 Haskell 这样的纯函数式编程语言中也有 Lens \supercite{Foster2007} 这样可以当做指针的对应物的语言结构。

指针的广泛存在给编译优化、静态程序分析带来困难和挑战。比如在下面这个C语言代码片段中，


\begin{CVerbatim}
for(i = 0; i < *p; i++) {
    a[i] = 0;
}	
\end{CVerbatim}		
编译器不能简单地将代码变换为：
\begin{CVerbatim}
int n = *p;
for(i = 0; i < n; i++) {
    a[i] = 0;
}	
\end{CVerbatim}		
的形式。因为如果 \verb|a+i| 和 \verb|p| 指向同一片内存的话，这两段程序的效果是不一样的，于是编译器需要先对程序中指针变量能指向的位置进行分析（即“指针分析”）后才能再进行很多有效的代码优化。指针分析在众多静态软件分析问题中也扮演着基础性的角色，如对C语言程序进行静态的内存泄漏检查的问题中，也需要知道程序中指针变量可能指向哪些堆上的内存对象，以及哪些堆上的内存对象已经通过指针被释放。

从1980年Weihl等人第一次提出指针分析问题\supercite{weihl1980interprocedural}至今，学界对指针分析问题进行了大量研究。其中近年来较有影响力的包括Lattner等人的 Data Structure Analysis 分析算法 （DSA） \supercite{Lattner2007}。DSA是一个上下文敏感、域敏感（field-sensitive）的分析算法，其与更早研究成果的主要区别是该算法对堆上的内存对象的建模方式不是简单将每一条分配语句（如C中的 \verb|malloc()| 语句）抽象为一个堆对象，而是把在不同函数调用上下文下被执行的同一条分配语句当做不同的内存对象 （称之为 heap cloning，或 heap specialization \supercite{nystrom2004importance}，本文中称作“堆上下文敏感”），也就是说DSA能够区分在不同位置通过同一辅助函数被创建的内存对象。DSA是第一个在无环调用路径上能实现完整 heap cloning 的高效分析算法。

近年来另一有影响力的研究成果是Hardekopf与Lin发展的基于子集的流敏感指针分析 \supercite{Hardekopf2007} \supercite{hardekopf2007exploiting} \supercite{Hardekopf2009}  \supercite{Hardekopf2011} \supercite{hardekopf2011flow}。其最先进的成果 Staged Flow-sensitive Analysis (SFS) \supercite{hardekopf2011flow} 是一个流敏感、基于子集、但上下文不敏感的高效分析算法。

Lattner等人的DSA分析算法是是流不敏感、上下文敏感、堆上下文敏感的基于合一（ unification-based ）指针分析，而Hardekopf等人的SFS则是一个流敏感，但上下文不敏感、堆上下文不敏感的基于子集 （subset-based）指针分析。可以看出，这两个算法对“指针分析”这同一问题的处理颇为不同，但得到的算法的优势恰是互补的。那么一个自然的问题是，能否设计出一个兼具两者优点的高效指针分析算法呢？从这个角度出发，本文作者在单调数据流框架下对这两个算法进行了分析，并设计出一个兼具两者优点的，即上下文敏感、流敏感、且堆上下文敏感的指针分析算法。在本文描述的分析框架下，流不敏感指针分析总是流敏感指针分析的特例，而基于合一的算法与用BDD优化的基于子集的算法都被视作对集合进行压缩编码的一类优化方法的特列。

我们的算法在过程内使用类似于SFS的方式进行流敏感的指针分析，并得到整个函数对内存的操作的一个“归纳” （Summary，相当于DSA对函数进行局部分析的结果），然后我们再按照函数调用图将各函数的Summary内联到它的调用者中，并对调用者的数据流分析结果进行更新。因为采用内联支持上下文敏感的方法要求局部分析的单调性，而流敏感分析中对 strong-update 的特性违反了单调性，故我们对函数参数、全局变量放弃 strong-update，对其余变量仍支持 strong-update。{ \color{red} TODO }本算法与DSA算法在实验评估中的结果表明，我们的流敏感分析算法能显著提高指针分析的准确率。

本文余下部分按如下方式组织：
\begin{itemize}
\item 第\ref{relatedWork}章定义指针分析研究中几个“敏感性”的概念以及与本文相关的研究工作。
\item 第\ref{algorithm}章介绍我们设计的流敏感、上下文敏感、堆上下文敏感分析算法。
\item 第\ref{proof}章在单调数据流框架下证明我们算法的正确性，并分析其与相关算法的联系。
\item 第\ref{evaluation}章对本文提出的算法进行实验评估。
\item 第\ref{application}章指出一些本文提出的分析算法的应用场景。
\item 第\ref{conclusion}章总结全文并预测未来的研究方向。
\end{itemize}

%% 那么一个自然的问题是，能否将这两个算法对指针分析的处理统一在一致的理论框架下，并设计出一个兼具两者优点的，既上下文敏感且流敏感的指针分析算法呢？想要如此，我们需要分析回答如下问题：
%% 
%% \begin{enumerate}[topsep=1em, itemsep=1em]
%% 
%% \item 能否找到一个理论框架能够同时解释流敏感和流不敏感的指针分析？在这个框架下两者有怎样的理论联系？比如，流不敏感指针分析在何种情况下是流敏感指针分析的特列？ \label{q1}
%% 
%% \item 利用 Union-Find 数据结构\supercite{gabow1983linear} 的基于合一的指针分析\supercite{Steensgaard1996}和利用 Binary Decision Diagram （BDD）优化的基于子集的指针分析\supercite{Whaley2004}能否看作是某一通用方法的两个不同特例？又是否能在同一优化方法下利用更新奇、高效的数据结构获得更大的优化幅度。\label{q2}
%% 
%% \item 流敏感指针分析，尤其是因为支持 strong-update 所以转移函数不具备单调性的流敏感指针分析，在与很大程度上依靠单调性质来进行模块化分析的上下文敏感指针分析结合在一起时，该如何保持 strong-update 的特性并保证算法的正确性。\label{q3}
%% 
%% \end{enumerate}
%% 
%% 
%% 问题 \ref{q1} 尝试统一流敏感和流不敏感指针分析，是本研究的基础性问题，只有找到一个一致的理论框架我们才能细致的鉴别两类算法的区别与联系，以及指导我们将两类算法结合在一起的方法。问题 \ref{q2} 则尝试统一“基于子集”和“基于合一”的两类优化算法。问题 \ref{q3} 则解决流敏感指针分析与上下文敏感指针分析在单调性上的冲突。
%% 
%% 本研究对问题 \ref{q1} 的回答是在单调数据流分析框架下对两类算法进行分析，我们证明无论是基于基于合一的指针分析算法还是基于子集的指针分析算法，流不敏感分析算法的结果等同于相应的流敏感算法在函数出口的局部分析结果。
%% 
%% 对于问题 \ref{q2} ，我们将使用Union-Find进行基于合一的分析方法与使用BDD进行基于子集的分析方法都视作是使用一种数据结构对集合进行压缩编码的方法，其中BDD是无损编码方法，而使用Union-Find则是有损压缩编码的方法。基于这样的观点，我们可以设计使用更先进的数据结构进行更高效的压缩，从而得到新的指针分析算法。
%% 
%% 在对问题 \ref{q1} 和 \ref{q2} 的回答基础上，我们设计了一个流敏感且上下文敏感的指针分析算法。其在过程内使用类似于SFS的方式进行流敏感的指针分析，并得到整个函数对内存的操作的一个“总结” （Summary，相当于DSA对函数进行局部分析的结果），然后我们再按照函数调用图将各函数的Summary内联到它的调用者中，并对调用者的数据流分析结果进行更新。作为我们对问题 \ref{q3} 的回答，我们的算法对于函数参数、全局变量放弃 strong-update，对其余变量仍支持 strong-update。我们仍然在单调数据流分析的结果下对我们的算法正确性进行严格的证明。{ \color{red} TODO }本算法与DSA算法在实验评估中的结果表明，我们的流敏感分析算法能显著提高指针分析的准确率。
%% 
%% 本文余下部分按如下方式组织：
%% \begin{itemize}
%% \item 第\ref{relatedWork}章定义指针分析研究中几个“敏感性”的概念以及与本文相关的研究工作。
%% \item 第\ref{algorithm}章介绍我们设计的流敏感、上下文敏感分析算法。
%% \item 第\ref{proof}章在单调数据流框架下证明我们算法的正确性，并分析其与相关算法的联系。
%% \item 第\ref{evaluation}章对本文提出的算法进行实验评估。
%% \item 第\ref{application}章指出一些本文的流敏感、上下文敏感分析算法的应用场景。
%% \item 第\ref{conclusion}章总结全文并预测未来的研究方向。
%% \end{itemize}

% vim:ts=4:sw=4
